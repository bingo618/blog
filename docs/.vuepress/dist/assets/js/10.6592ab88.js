(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{211:function(t,a,s){"use strict";s.r(a);var e=s(28),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"javascript内存管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#javascript内存管理"}},[t._v("#")]),t._v(" JavaScript内存管理")]),t._v(" "),s("h2",{attrs:{id:"一、javascript数据的储存方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、javascript数据的储存方式"}},[t._v("#")]),t._v(" 一、JavaScript数据的储存方式")]),t._v(" "),s("p",[t._v("原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的。")]),t._v(" "),s("h3",{attrs:{id:"_1-1-栈-stack-空间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-栈-stack-空间"}},[t._v("#")]),t._v(" 1.1 栈(stack)空间")]),t._v(" "),s("p",[t._v("栈是一种常用的数据结构，具有"),s("strong",[t._v("先进后出，后进先出")]),t._v("的特点。")]),t._v(" "),s("p",[t._v("要简单理解栈的存取方式，我们可以通过类比乒乓球盒子来分析。如下图左侧。\n"),s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/webp/184136/1591343485073-4ab29e6e-f3eb-4841-9efb-88bd630bd30a.webp#align=left&display=inline&height=550&margin=%5Bobject%20Object%5D&name=599584-b12fef30803a0c53.webp&originHeight=550&originWidth=700&size=12726&status=done&style=none&width=700",alt:"599584-b12fef30803a0c53.webp"}})]),t._v(" "),s("h3",{attrs:{id:"_1-2-堆-heap-空间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-堆-heap-空间"}},[t._v("#")]),t._v(" 1.2 堆(heap)空间")]),t._v(" "),s("p",[t._v("堆数据结构是一种树状结构。它的存取数据的方式，则与书架与书非常相似。")]),t._v(" "),s("p",[t._v("书虽然也整齐的存放在书架上，但是我们只要知道书的名字，就可以很方便的取出我们想要的书，而不用像从乒乓球盒子里取乒乓一样，非得将上面的所有乒乓球拿出来才能取到中间的某一个乒乓球。好比在JSON格式的数据中，我们存储的"),s("code",[t._v("key-value")]),t._v("是可以无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。")]),t._v(" "),s("h3",{attrs:{id:"_1-4-javascrip数据的储存位置的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-javascrip数据的储存位置的区别"}},[t._v("#")]),t._v(" 1.4 JavaScrip数据的储存位置的区别")]),t._v(" "),s("ul",[s("li",[t._v("基本类型")])]),t._v(" "),s("p",[t._v("Undefined,Boolean,Null,Stiring,Number,Symbol,BigInt类型是存存在栈空间的。\n这里的栈空间就是"),s("strong",[t._v("调用栈")]),t._v("，是用来存储"),s("strong",[t._v("执行上下文")]),t._v("的，当执行一段代码时，需要先编译，并创建执行上下文，然后再按照顺序执行代码，\n变量的值都被保存在执行上下文中，而执行上下文又被压入到栈中，所以可以认为变量的值都是存放在栈中的。")]),t._v(" "),s("ul",[s("li",[t._v("引用类型")])]),t._v(" "),s("p",[t._v("Object类型的值是保存在堆空间中的，执行上下文中的变量只保存"),s("strong",[t._v("堆内存的地址")]),t._v("。当我们要访问堆内存中的引用数据类型时，实际上我们首先获取了该对象的地址引用（或者地址指针），然后再从堆内存中取得我们需要的数据。")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 变量对象")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'this is string'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 变量对象")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a3 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 变量对象")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" m"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 变量b存在于变量对象中，{m: 20} 作为对象存在于堆内存中")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" c "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 变量c存在于变量对象中，[1, 2, 3] 作为对象存在于堆内存中")]),t._v("\n")])])]),s("p",[s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/webp/184136/1591409647360-b6fc6ed1-f369-4fcc-be60-c48e975fddc8.webp#align=left&display=inline&height=400&margin=%5Bobject%20Object%5D&name=599584-8e93616d7afcf811.webp&originHeight=400&originWidth=700&size=10548&status=done&style=none&width=700",alt:"599584-8e93616d7afcf811.webp"}}),t._v("\n所以通常情况下，"),s("strong",[t._v("栈空间都不会设置太大，主要用来存放一些原始类型的小数据")]),t._v("。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，"),s("strong",[t._v("堆空间很大，能存放很多大的数据")]),t._v("，不过缺点是分配内存和回收内存都会占用一定的时间。")]),t._v(" "),s("h3",{attrs:{id:"_1-5-javascript赋值操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-javascript赋值操作"}},[t._v("#")]),t._v(" 1.5 JavaScript赋值操作")]),t._v(" "),s("p",[s("strong",[t._v("原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。")])]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// demo01.js")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" b "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nb "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("30")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这时a的值是多少？")]),t._v("\n")])])]),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// demo02.js")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" m "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" n "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" m"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nn"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("15")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 这时m.a的值是多少")]),t._v("\n")])])]),s("p",[t._v("如下图所示：")]),t._v(" "),s("ul",[s("li",[t._v("基本类型复制变量：")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/webp/184136/1591410028268-8012f0cc-6548-4130-87ec-778ff8b55119.webp#align=left&display=inline&height=300&margin=%5Bobject%20Object%5D&name=599584-959cc758fb313a03.webp&originHeight=300&originWidth=700&size=6842&status=done&style=none&width=700",alt:"599584-959cc758fb313a03.webp"}})]),t._v(" "),s("ul",[s("li",[t._v("引用类型复制变量")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/webp/184136/1591410101329-8dfddf64-c942-4be3-aa2c-d332ac1beff0.webp#align=left&display=inline&height=700&margin=%5Bobject%20Object%5D&name=599584-c269c4c5cae7d537.webp&originHeight=700&originWidth=700&size=14450&status=done&style=none&width=700",alt:"599584-c269c4c5cae7d537.webp"}})]),t._v(" "),s("h3",{attrs:{id:"_1-6-闭包的内存模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-闭包的内存模型"}},[t._v("#")]),t._v(" 1.6 闭包的内存模型")]),t._v(" "),s("p",[t._v("当 JavaScript 引擎执行一个函数时，首先会编译，并创建一个空执行上下文。在编译过程中，遇到内部函数JavaScript 引擎还要对内部函数做一次快速的词法扫描，若发现该内部函数引用了外部函数中的变量，JavaScript 引擎就会判断这是一个闭包，于是在堆空间创建换一个“closure”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存外部变量。\n由于闭包就产生了，当外部函数执行结束之后，而内部函数都引用“clourse”对象，所以即使外部函数退出了，“clourse”依然被其内部的方法引用。总的来说，产生闭包的核心有两步："),s("strong",[t._v("第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。")]),t._v("\n**")]),t._v(" "),s("h2",{attrs:{id:"二、javascript的垃圾回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、javascript的垃圾回收"}},[t._v("#")]),t._v(" 二、JavaScript的垃圾回收")]),t._v(" "),s("h3",{attrs:{id:"_2-1-内存泄漏"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-内存泄漏"}},[t._v("#")]),t._v(" 2.1 内存泄漏")]),t._v(" "),s("p",[t._v("程序在执行时分配的内存，在数据使用后不再需要时若没有及时对这些"),s("strong",[t._v("垃圾数据")]),t._v("进行回收，以释放有限的内存空间，就会产生"),s("strong",[t._v("内存泄漏")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"_2-2-调用栈中的数据是如何回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-调用栈中的数据是如何回收"}},[t._v("#")]),t._v(" 2.2 调用栈中的数据是如何回收")]),t._v(" "),s("p",[t._v("JavaScript 引擎遇到函数创建函数的执行上下文，并将函数的执行上下文压入到调用栈中，最终执行到函数时，还有一个记录当前执行状态的指针（称为 ESP），指向调用栈中 当前函数的执行上下文，表示当前正在执行 showName 函数。接着，当函数执行完成之后，函数执行流程就进入另一个函数，那这时就需要销毁当前函数的执行上下文了。ESP 这时候就帮上忙了，JavaScript 会将 ESP 下移到另一个函数的执行上下文，这个下移操作就是销毁当前函数执行上下文的过程。\n"),s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/184136/1591411166229-414937b6-37f1-4131-8b1b-387c262a8298.png#align=left&display=inline&height=614&margin=%5Bobject%20Object%5D&name=b1f0573287b487016334c3f8ec23073b.png&originHeight=614&originWidth=1142&size=256456&status=done&style=none&width=1142",alt:"b1f0573287b487016334c3f8ec23073b.png"}}),t._v("\n所以，当一个函数执行结束之后，"),s("strong",[t._v("JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"_2-3-堆中的数据是如何回收的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-堆中的数据是如何回收的"}},[t._v("#")]),t._v(" 2.3 堆中的数据是如何回收的")]),t._v(" "),s("p",[t._v("要回收堆中的垃圾数据，就需要用到 JavaScript 中的"),s("strong",[t._v("垃圾回收器")]),t._v("了。")]),t._v(" "),s("h4",{attrs:{id:"_2-3-1-代际假说"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-1-代际假说"}},[t._v("#")]),t._v(" 2.3.1 代际假说")]),t._v(" "),s("ul",[s("li",[t._v("第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；")]),t._v(" "),s("li",[t._v("第二个是不死的对象，会活得更久。")])]),t._v(" "),s("p",[t._v("在 V8 中会把堆分为"),s("strong",[t._v("新生代")]),t._v("和"),s("strong",[t._v("老生代")]),t._v("两个区域，"),s("strong",[t._v("新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象")]),t._v("。")]),t._v(" "),s("h4",{attrs:{id:"_2-3-2-垃圾回收器的工作流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-2-垃圾回收器的工作流程"}},[t._v("#")]),t._v(" 2.3.2 垃圾回收器的工作流程")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("第一步是标记空间中"),s("strong",[t._v("活动对象（"),s("strong",[t._v("使用的对象")]),t._v("）"),s("strong",[t._v("和")]),t._v("非活动对象（"),s("strong",[t._v("可以进行垃圾回收的对象")]),t._v("）")]),t._v("。")])]),t._v(" "),s("li",[s("p",[t._v("第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。")])]),t._v(" "),s("li",[s("p",[t._v("第三步是做"),s("strong",[t._v("内存整理")]),t._v("。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为"),s("strong",[t._v("内存碎片")]),t._v("。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片。")])])]),t._v(" "),s("p",[t._v("我们就按照这个流程来分析"),s("strong",[t._v("新生代垃圾回收器（副垃圾回收器")]),t._v("）和**老生代垃圾回收器（主垃圾回收器）**是如何处理垃圾回收的。")]),t._v(" "),s("h4",{attrs:{id:"_2-3-2-新生代区域垃圾回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-2-新生代区域垃圾回收"}},[t._v("#")]),t._v(" 2.3.2 "),s("strong",[t._v("新生代区域垃圾回收")])]),t._v(" "),s("p",[t._v("**\n大多数"),s("strong",[t._v("小的对象")]),t._v("都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁。")]),t._v(" "),s("p",[t._v("新生代中用** Scavenge 算法**来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，**一半是对象区域，一半是空闲区域。\n**\n"),s("strong",[s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/184136/1591411817483-a15cf2d6-ad33-483b-8ffc-db28521208d2.png#align=left&display=inline&height=550&margin=%5Bobject%20Object%5D&name=4f9310c7da631fa5a57f871099bfbeaf.png&originHeight=550&originWidth=1142&size=91924&status=done&style=none&width=1142",alt:"4f9310c7da631fa5a57f871099bfbeaf.png"}})])]),t._v(" "),s("p",[t._v("新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。")]),t._v(" "),s("p",[t._v("在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。")]),t._v(" "),s("p",[t._v("完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种"),s("strong",[t._v("角色翻转的操作还能让新生代中的这两块区域无限重复使用下去")]),t._v("。")]),t._v(" "),s("p",[t._v("由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，"),s("strong",[t._v("所以为了执行效率，一般新生区的空间会被设置得比较小")]),t._v("。")]),t._v(" "),s("p",[t._v("也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了"),s("strong",[t._v("对象晋升策略")]),t._v("，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。")]),t._v(" "),s("h4",{attrs:{id:"_2-3-2-老生代区域垃圾回收"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-2-老生代区域垃圾回收"}},[t._v("#")]),t._v(" 2.3.2 "),s("strong",[t._v("老生代区域垃圾回收")])]),t._v(" "),s("p",[s("strong",[t._v("主垃圾回收器")]),t._v("主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，"),s("strong",[t._v("一个是对象占用空间大，另一个是对象存活时间长")]),t._v("。")]),t._v(" "),s("ol",[s("li",[t._v("**标记 - 清除（Mark-Sweep）\n**")])]),t._v(" "),s("p",[t._v("首先是标记过程阶段。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为"),s("strong",[t._v("活动对象")]),t._v("，没有到达的元素就可以判断为"),s("strong",[t._v("垃圾数据")]),t._v("。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/184136/1591412220727-9f57c449-93ca-4a03-8ef1-0f52b2fa9847.png#align=left&display=inline&height=564&margin=%5Bobject%20Object%5D&name=d015db8ad0df7f0ccb1bdb8e31f96e85.png&originHeight=564&originWidth=1142&size=51701&status=done&style=none&width=1142",alt:"d015db8ad0df7f0ccb1bdb8e31f96e85.png"}})]),t._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[s("strong",[t._v("标记 - 整理（Mark-Compact）")])])]),t._v(" "),s("p",[t._v("上面的标记过程和清除过程就是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记 - 整理（Mark-Compact），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n"),s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/png/184136/1591412275728-87790b61-cb12-4b8f-b6cf-b167495dcd7e.png#align=left&display=inline&height=441&margin=%5Bobject%20Object%5D&name=652bd2df726d0aa5e67fe8489f39a18c.png&originHeight=441&originWidth=1142&size=38800&status=done&style=none&width=1142",alt:"652bd2df726d0aa5e67fe8489f39a18c.png"}}),t._v(" "),s("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2020/svg/184136/1591426625532-c087d572-71b8-4ec2-a0a8-bfcd206151b3.svg",alt:""}})])])}),[],!1,null,null,null);a.default=n.exports}}]);